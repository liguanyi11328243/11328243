#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define SIZE 9
#define EMPTY 0
#define MAX_WRONG 3
#define MAX_HINTS 3

#define COLOR_GREEN "\x1b[32m"
#define COLOR_RED "\x1b[31m"
#define COLOR_RESET "\x1b[0m"

int board[SIZE][SIZE];
int solution[SIZE][SIZE];
int user_correct[SIZE][SIZE] = {0}; // ä½¿ç”¨è€…æ­£ç¢ºå¡«å…¥çš„æ ¼å­
int digit_count[SIZE + 1] = {0};     // æ•¸å­— 1~9 å‡ºç¾æ¬¡æ•¸

int is_safe(int row, int col, int num) {
    for (int x = 0; x < SIZE; x++) {
        if (board[row][x] == num || board[x][col] == num ||
            board[(row / 3) * 3 + x / 3][(col / 3) * 3 + x % 3] == num)
            return 0;
    }
    return 1;
}

int fill_board() {
    for (int row = 0; row < SIZE; row++) {
        for (int col = 0; col < SIZE; col++) {
            if (board[row][col] == EMPTY) {
                int nums[SIZE];
                for (int i = 0; i < SIZE; i++) nums[i] = i + 1;

                // æ‰“äº‚é †åº
                for (int i = 0; i < SIZE - 1; i++) {
                    int j = i + rand() / (RAND_MAX / (SIZE - i) + 1);
                    int t = nums[j];
                    nums[j] = nums[i];
                    nums[i] = t;
                }

                for (int i = 0; i < SIZE; i++) {
                    if (is_safe(row, col, nums[i])) {
                        board[row][col] = nums[i];
                        if (fill_board()) return 1;
                        board[row][col] = EMPTY;
                    }
                }
                return 0;
            }
        }
    }
    return 1;
}

void copy_board_to_solution() {
    for (int i = 0; i < SIZE; i++)
        for (int j = 0; j < SIZE; j++)
            solution[i][j] = board[i][j];
}

void remove_cells(int clues) {
    int removed = 0;
    while (removed < (SIZE * SIZE - clues)) {
        int row = rand() % SIZE;
        int col = rand() % SIZE;
        if (board[row][col] != EMPTY) {
            board[row][col] = EMPTY;
            removed++;
        }
    }
}

void print_horizontal_border() {
    printf("+");
    for (int i = 0; i < SIZE; i++) {
        printf("---");
        if ((i + 1) % 3 == 0) printf("+");
    }
    printf("\n");
}

void print_board() {
    print_horizontal_border();
    for (int i = 0; i < SIZE; i++) {
        printf("|");
        for (int j = 0; j < SIZE; j++) {
            if (board[i][j] == EMPTY) {
                printf(" . ");
            } else if (user_correct[i][j]) {
                printf(COLOR_GREEN " %d " COLOR_RESET, board[i][j]);
            } else {
                printf(" %d ", board[i][j]);
            }

            if ((j + 1) % 3 == 0) printf("|");
        }
        printf("\n");
        if ((i + 1) % 3 == 0) print_horizontal_border();
    }

    printf("å°šæœªå¡«æ»¿æ•¸å­—ï¼š");
    int shown = 0;
    for (int i = 1; i <= SIZE; i++) {
        if (digit_count[i] < 9) {
            printf("%d ", i);
            shown = 1;
        }
    }
    if (!shown) printf("ç„¡");
    printf("\n\n");
}

int is_board_full() {
    for (int i = 0; i < SIZE; i++)
        for (int j = 0; j < SIZE; j++)
            if (board[i][j] == EMPTY) return 0;
    return 1;
}

void give_hint() {
    int empty_cells[SIZE * SIZE][2];
    int count = 0;

    for (int i = 0; i < SIZE; i++)
        for (int j = 0; j < SIZE; j++)
            if (board[i][j] == EMPTY) {
                empty_cells[count][0] = i;
                empty_cells[count][1] = j;
                count++;
            }

    if (count == 0) {
        printf("å·²ç„¡å¯æç¤ºæ ¼ã€‚\n");
        return;
    }

    int index = rand() % count;
    int row = empty_cells[index][0];
    int col = empty_cells[index][1];
    int val = solution[row][col];
    board[row][col] = val;
    digit_count[val]++;
    user_correct[row][col] = 1;

    printf("æç¤ºï¼šå·²å¡«å…¥ (%d, %d) = %d\n\n", row + 1, col + 1, val);
    if (digit_count[val] == 9)
        printf("ğŸ”’ æ•¸å­— %d å·²å¡«æ»¿ï¼Œç„¡æ³•å†è¼¸å…¥ã€‚\n", val);
}

int main() {
    srand((unsigned int)time(NULL));
    time_t start_time, end_time;

    for (int i = 0; i < SIZE; i++)
        for (int j = 0; j < SIZE; j++)
            board[i][j] = EMPTY;

    if (!fill_board()) {
        printf("ç”Ÿæˆå¤±æ•—ã€‚\n");
        return 1;
    }

    copy_board_to_solution();

    int clues = 30;
    remove_cells(clues);

    // åˆå§‹åŒ– digit_count
    for (int i = 0; i < SIZE; i++)
        for (int j = 0; j < SIZE; j++)
            if (board[i][j] != EMPTY)
                digit_count[board[i][j]]++;

    printf("ğŸ® æ­¡è¿ä¾†ç©æ•¸ç¨ï¼\n");
    printf("è¼¸å…¥æ ¼å¼ï¼šåˆ—(1-9) è¡Œ(1-9) æ•¸å­—(1-9)ï¼Œè¼¸å…¥ 0 è¦æ±‚æç¤ºï¼ˆæœ€å¤š3æ¬¡ï¼‰ã€‚\n");
    printf("ç­”éŒ¯ä¸‰æ¬¡éŠæˆ²çµæŸï¼\n\n");

    time(&start_time);
    int wrong_count = 0, hint_count = 0;

    while (1) {
        print_board();

        if (is_board_full()) {
            time(&end_time);
            double seconds = difftime(end_time, start_time);
            printf("ğŸ‰ æ­å–œå®Œæˆæ•¸ç¨ï¼ä½ è´äº†ï¼\n");
            printf("â±ï¸ èŠ±è²»æ™‚é–“ï¼š%.0f ç§’\n", seconds);
            break;
        }

        int r, c, val;
        printf("è«‹è¼¸å…¥ (åˆ— è¡Œ æ•¸å­—)ï¼Œæˆ–æ•¸å­— 0 è¦æ±‚æç¤ºï¼š");
        int res = scanf("%d %d %d", &r, &c, &val);
        if (res != 3) {
            printf("è«‹è¼¸å…¥ä¸‰å€‹æ•´æ•¸ã€‚\n");
            while (getchar() != '\n');
            continue;
        }

        if (val == 0) {
            if (hint_count >= MAX_HINTS) {
                printf("âš ï¸ æç¤ºæ¬¡æ•¸å·²ç”¨å®Œï¼ˆæœ€å¤š %d æ¬¡ï¼‰ã€‚\n\n", MAX_HINTS);
            } else {
                give_hint();
                hint_count++;
                printf("ğŸ“Œ å·²ä½¿ç”¨æç¤ºæ¬¡æ•¸ï¼š%d / %d\n\n", hint_count, MAX_HINTS);
            }
            continue;
        }

        if (r < 1 || r > 9 || c < 1 || c > 9 || val < 1 || val > 9) {
            printf("æ•¸å­—ç¯„åœéŒ¯èª¤ã€‚\n");
            continue;
        }

        if (digit_count[val] >= 9) {
            printf(COLOR_RED "âš ï¸ æ•¸å­— %d å·²å¡«æ»¿ï¼Œè«‹é¸æ“‡å…¶ä»–æ•¸å­—ã€‚\n\n" COLOR_RESET, val);
            continue;
        }

        r--; c--;

        if (board[r][c] != EMPTY) {
            printf("æ­¤æ ¼å·²æœ‰æ•¸å­—ï¼Œè«‹é¸æ“‡ç©ºæ ¼ã€‚\n");
            continue;
        }

        if (solution[r][c] == val) {
            board[r][c] = val;
            digit_count[val]++;
            user_correct[r][c] = 1;
            printf(COLOR_GREEN "âœ… ç­”å°äº†ï¼\n\n" COLOR_RESET);
            if (digit_count[val] == 9)
                printf("ğŸ”’ æ•¸å­— %d å·²å¡«æ»¿ï¼Œç„¡æ³•å†è¼¸å…¥ã€‚\n", val);
        } else {
            wrong_count++;
            printf(COLOR_RED "âŒ ç­”éŒ¯ï¼éŒ¯èª¤æ¬¡æ•¸ï¼š%d / %d\n\n" COLOR_RESET, wrong_count, MAX_WRONG);
            if (wrong_count >= MAX_WRONG) {
                time(&end_time);
                double seconds = difftime(end_time, start_time);
                printf("ğŸ’€ éŒ¯èª¤è¶…éä¸‰æ¬¡ï¼ŒéŠæˆ²å¤±æ•—ã€‚\n");
                printf("â±ï¸ èŠ±è²»æ™‚é–“ï¼š%.0f ç§’\n", seconds);
                printf("æ­£ç¢ºè§£ç­”å¦‚ä¸‹ï¼š\n");
                for (int i = 0; i < SIZE; i++) {
                    for (int j = 0; j < SIZE; j++) {
                        printf("%d ", solution[i][j]);
                    }
                    printf("\n");
                }
                break;
            }
        }
    }

    return 0;
}
